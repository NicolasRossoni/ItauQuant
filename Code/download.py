"""
download.py

Script principal de download de dados de futuros de commodities.
Este √© um FLUXOGRAMA LIMPO que abstrai toda complexidade no m√≥dulo src/Download.py.

CONFIGURA√á√ïES (in√≠cio do arquivo - modificar aqui):
"""

# ==========================================
# CONFIGURA√á√ïES - MODIFICAR AQUI
# ==========================================

DATASET_ID = "WTI_test_380d"             # ID do dataset a ser criado (18 meses)
DATA_SOURCE = "yahoo"                   # Fonte dos dados: "yahoo", "cme" ou "synthetic"
START_DATE = "2023-07-01"               # Data inicial dos dados (YYYY-MM-DD) - ~380 dias √∫teis
END_DATE = "2024-12-31"                 # Data final dos dados (YYYY-MM-DD)
NUM_TENORS = 6                          # N√∫mero de tenores (meses) a baixar
COMMODITY = "WTI"                       # Commodity (para CME): "WTI", "NG", etc.

# Configura√ß√µes avan√ßadas (opcional)
CONTANGO_MONTHLY = 0.004                # Contango mensal para Yahoo Finance (0.4%)
BASE_PRICE = 80.0                       # Pre√ßo base para dados sint√©ticos
VOLATILITY = 0.25                       # Volatilidade anual para sint√©ticos (25%)

# ==========================================
# FLUXOGRAMA PRINCIPAL
# ==========================================

import sys
import os
import numpy as np
from src.Download import (
    download_yahoo_wti, 
    download_cme_data, 
    create_synthetic_dataset,
    format_raw_data,
    save_raw_dataset
)

def main():
    """
    Fluxograma principal de download de dados.
    
    Input: Configura√ß√µes definidas no in√≠cio do arquivo
    Output: 
    - Print minimalista no terminal mostrando progresso
    - Arquivos salvos em data/raw/{DATASET_ID}/ com estrutura padronizada:
      * F_mkt.csv: pre√ßos futuros [T x M]
      * ttm.csv: time-to-maturity [T x M]  
      * S.csv: pre√ßos spot [T] (opcional)
      * costs.csv: custos por tenor [M]
      * info.json: metadados do dataset
    """
    
    print("=" * 80)
    print("üöÄ DOWNLOAD DE DADOS - ITAU QUANT")
    print("=" * 80)
    print(f"üîß CONFIGURA√á√ïES DETECTADAS:")
    print(f"   ‚Ä¢ Dataset ID: {DATASET_ID}")
    print(f"   ‚Ä¢ Fonte de dados: {DATA_SOURCE.upper()}")
    print(f"   ‚Ä¢ Per√≠odo solicitado: {START_DATE} ‚Üí {END_DATE}")
    print(f"   ‚Ä¢ N√∫mero de tenores: {NUM_TENORS}")
    print(f"   ‚Ä¢ Contango mensal: {CONTANGO_MONTHLY:.3%}")
    print(f"   ‚Ä¢ Commodity (CME): {COMMODITY}")
    
    # Valida√ß√£o inicial das configura√ß√µes
    from datetime import datetime
    try:
        start_dt = datetime.strptime(START_DATE, '%Y-%m-%d')
        end_dt = datetime.strptime(END_DATE, '%Y-%m-%d')
        days_span = (end_dt - start_dt).days
        print(f"   ‚Ä¢ Per√≠odo em dias: {days_span} dias")
        print(f"   ‚Ä¢ Per√≠odo em anos: {days_span/365.25:.2f} anos")
        
        if days_span < 100:
            print(f"   ‚ö†Ô∏è  AVISO: Per√≠odo curto ({days_span} dias) - pode impactar calibra√ß√£o")
        elif days_span > 1000:
            print(f"   ‚ÑπÔ∏è  NOTA: Per√≠odo longo ({days_span} dias) - download pode demorar")
        
    except Exception as e:
        print(f"   ‚ùå ERRO na valida√ß√£o de datas: {e}")
    
    print()
    
    # PASSO 1: Baixar dados conforme fonte selecionada
    print("üì• PASSO 1: EXECUTANDO DOWNLOAD DE DADOS")
    print(f"   üîÑ Iniciando download via {DATA_SOURCE.upper()}...")
    
    try:
        if DATA_SOURCE.lower() == "yahoo":
            print(f"   üì° Conectando ao Yahoo Finance para s√≠mbolo CL=F...")
            print(f"   üèóÔ∏è  Criando estrutura de termo sint√©tica com contango {CONTANGO_MONTHLY:.3%}...")
            
            raw_data = download_yahoo_wti(
                start_date=START_DATE,
                end_date=END_DATE, 
                num_tenors=NUM_TENORS,
                contango_monthly=CONTANGO_MONTHLY
            )
            
        elif DATA_SOURCE.lower() == "cme":
            print(f"   üì° Conectando √† API CME para commodity {COMMODITY}...")
            print(f"   ‚ö†Ô∏è  ATEN√á√ÉO: CME √© placeholder - gerando dados sint√©ticos")
            
            raw_data = download_cme_data(
                commodity=COMMODITY,
                start_date=START_DATE,
                end_date=END_DATE
            )
            
        elif DATA_SOURCE.lower() == "synthetic":
            print(f"   üé≤ Gerando dados sint√©ticos com GBM...")
            print(f"   üìä Par√¢metros: pre√ßo_base={BASE_PRICE}, vol={VOLATILITY:.1%}")
            
            dataset_path = create_synthetic_dataset(
                dataset_id=DATASET_ID,
                start_date=START_DATE,
                end_date=END_DATE,
                num_tenors=NUM_TENORS,
                base_price=BASE_PRICE,
                volatility=VOLATILITY
            )
            print("‚úÖ PASSO 1: Download sint√©tico conclu√≠do com sucesso!")
            print(f"üìÅ Dataset completo salvo em: {dataset_path}")
            print("üéâ EXECU√á√ÉO FINALIZADA - Dataset pronto para uso!")
            return
            
        else:
            raise ValueError(f"Fonte '{DATA_SOURCE}' n√£o suportada. Use: yahoo, cme ou synthetic")
        
        # Diagn√≥stico dos dados baixados
        F_mkt_shape = raw_data['F_mkt'].shape
        info = raw_data.get('info', {})
        
        print("‚úÖ PASSO 1: Download conclu√≠do com sucesso!")
        print(f"   üìä Dimens√µes dos dados: {F_mkt_shape[0]} dias √ó {F_mkt_shape[1]} tenores")
        print(f"   üí∞ Faixa de pre√ßos: ${info.get('price_range', {}).get('min', 0):.2f} - ${info.get('price_range', {}).get('max', 0):.2f}")
        print(f"   üìà Pre√ßo m√©dio: ${info.get('price_range', {}).get('mean', 0):.2f}")
        
        # Verifica√ß√£o de qualidade dos dados
        nan_count = raw_data['F_mkt'].isna().sum().sum()
        if nan_count > 0:
            print(f"   ‚ö†Ô∏è  ALERTA: {nan_count} valores NaN encontrados nos dados")
        else:
            print(f"   ‚úÖ Qualidade: Sem valores NaN detectados")
        
    except Exception as e:
        print(f"‚ùå ERRO CR√çTICO no PASSO 1: {e}")
        print(f"   üîç Tipo do erro: {type(e).__name__}")
        print(f"   üìù Detalhes: {str(e)}")
        sys.exit(1)
    
    # PASSO 2: Formatar dados para estrutura padr√£o
    print()
    print("üîß PASSO 2: FORMATANDO E VALIDANDO DADOS")
    print(f"   üîÑ Convertendo para estrutura padr√£o do projeto...")
    
    try:
        formatted_data = format_raw_data(raw_data, validate=True)
        
        # Diagn√≥stico detalhado da formata√ß√£o
        F_mkt = formatted_data['F_mkt']
        ttm = formatted_data['ttm']
        S = formatted_data.get('S')
        
        print("‚úÖ PASSO 2: Formata√ß√£o conclu√≠da com sucesso!")
        print(f"   üìä F_mkt: {F_mkt.shape} | dtype: {F_mkt.dtypes.iloc[0]}")
        print(f"   üìä ttm: {ttm.shape} | dtype: {ttm.dtypes.iloc[0]}")
        if S is not None:
            print(f"   üìä S (spot): {S.shape} | dtype: {S.dtype}")
        
        # Verifica√ß√µes de integridade
        if F_mkt.index.equals(ttm.index):
            print(f"   ‚úÖ √çndices temporais: F_mkt e ttm perfeitamente alinhados")
        else:
            print(f"   ‚ö†Ô∏è  ALERTA: Desalinhamento entre √≠ndices F_mkt e ttm")
        
        # Estat√≠sticas de volatilidade por tenor
        returns = F_mkt.pct_change().dropna()
        vol_by_tenor = returns.std() * np.sqrt(252)  # Anualizada
        print(f"   üìà Volatilidade anual por tenor: {vol_by_tenor.min():.1%} - {vol_by_tenor.max():.1%}")
        
    except Exception as e:
        print(f"‚ùå ERRO CR√çTICO no PASSO 2: {e}")
        print(f"   üîç Tipo do erro: {type(e).__name__}")
        print(f"   üìù Contexto: Formata√ß√£o de dados brutos para estrutura padr√£o")
        sys.exit(1)
    
    # PASSO 3: Salvar dataset na estrutura padronizada
    print()
    print("üíæ PASSO 3: SALVANDO DATASET NO SISTEMA DE ARQUIVOS")
    print(f"   üóÇÔ∏è  Criando estrutura em data/raw/{DATASET_ID}/...")
    
    try:
        dataset_path = save_raw_dataset(
            formatted_data=formatted_data,
            dataset_id=DATASET_ID,
            output_path="data/raw"
        )
        
        # Verifica√ß√£o dos arquivos salvos
        import os
        files_created = [f for f in os.listdir(dataset_path) if f.endswith(('.csv', '.json'))]
        total_size = sum(os.path.getsize(os.path.join(dataset_path, f)) for f in files_created)
        
        print("‚úÖ PASSO 3: Dataset salvo com sucesso!")
        print(f"   üìÅ Localiza√ß√£o: {dataset_path}")
        print(f"   üìÑ Arquivos criados: {len(files_created)} ({', '.join(files_created)})")
        print(f"   üíæ Tamanho total: {total_size/1024:.1f} KB")
        
    except Exception as e:
        print(f"‚ùå ERRO CR√çTICO no PASSO 3: {e}")
        print(f"   üîç Tipo do erro: {type(e).__name__}")
        print(f"   üìù Contexto: Salvamento do dataset formatado")
        sys.exit(1)
    
    # RESUMO FINAL COM DIAGN√ìSTICOS COMPLETOS
    print()
    print("=" * 80)
    print("üéâ EXECU√á√ÉO CONCLU√çDA COM SUCESSO!")
    print("=" * 80)
    print(f"üìÅ Dataset criado: {dataset_path}")
    
    # Estat√≠sticas detalhadas para debugging
    F_mkt = formatted_data['F_mkt']
    returns = F_mkt.pct_change().dropna()
    
    print(f"üìä DIAGN√ìSTICOS FINAIS:")
    print(f"   ‚Ä¢ Per√≠odo efetivo: {F_mkt.index[0].date()} ‚Üí {F_mkt.index[-1].date()}")
    print(f"   ‚Ä¢ Dias √∫teis dispon√≠veis: {len(F_mkt)}")
    print(f"   ‚Ä¢ Tenores configurados: {F_mkt.shape[1]}")
    print(f"   ‚Ä¢ Pre√ßo spot inicial: ${F_mkt.iloc[0, 0]:.2f}")
    print(f"   ‚Ä¢ Pre√ßo spot final: ${F_mkt.iloc[-1, 0]:.2f}")
    print(f"   ‚Ä¢ Retorno total (tenor 1): {(F_mkt.iloc[-1, 0] / F_mkt.iloc[0, 0] - 1):.2%}")
    print(f"   ‚Ä¢ Volatilidade di√°ria m√©dia: {returns.std().mean():.3%}")
    print(f"   ‚Ä¢ Correla√ß√£o m√©dia entre tenores: {F_mkt.corr().values[np.triu_indices_from(F_mkt.corr().values, k=1)].mean():.3f}")
    
    # Verifica√ß√£o da estrutura de termo
    final_prices = F_mkt.iloc[-1]
    contango_check = ((final_prices.iloc[1:].values / final_prices.iloc[:-1].values - 1) * 12).mean()  # Anualizado
    print(f"   ‚Ä¢ Contango m√©dio final: {contango_check:.2%} (esperado ~{CONTANGO_MONTHLY*12:.2%})")
    
    print()
    print("üöÄ PR√ìXIMOS PASSOS RECOMENDADOS:")
    print(f"   1. üß™ Teste b√°sico (5 dias): Modificar backtest.py com TEST_DAYS=5")
    print(f"   2. üî¨ Teste completo (50 dias): Ap√≥s valida√ß√£o do teste b√°sico")
    print(f"   3. üìä An√°lise completa: python Code/analysis.py")
    print(f"")
    print(f"üí° DICA DE DEBUG: Se algum passo falhar, verifique:")
    print(f"   ‚Ä¢ Conectividade de rede (Yahoo Finance)")
    print(f"   ‚Ä¢ Permiss√µes de escrita na pasta data/")
    print(f"   ‚Ä¢ Datas v√°lidas e em ordem cronol√≥gica")
    print()


if __name__ == "__main__":
    main()